# How to design Whatsapp

Whatsapp is a chat-based application. Once you know the design of Whatsapp application you would design any chat-based application with newer features.

### Functional and Non-functional Requirements

Functional Requirements
1. One to one Chat between Contacts (friends)
2. User doesn't need to be online always, but can receive previous offline messages when connected.   
3. Ability to create Groups with multiple Admins managing group members   
4. Sent + Delivered + Read receipts with Tick marks on the UI
5. Online/ Last Seen for your contacts
6. Image + Document sharing in chat messages
7. Simple User Registration with Mobile Number + SMS code.


Non-functional Requirements
1. The system should be highly available
2. The system should scale to handle millions of users 
3. The chats should happen in real-time with minimum latency
4. The chats should be end-to-end encrypted


### Storage of Messages

We could either store the messages forever on the database, or we could save the messages till they are read and then deleted from the system.
Given the current security scenarios, lets design the system so as to store the data encrypted on the server

### Communication Protocol

We need a bi-directional communication protocol, as the server could also initiate a request, eg when a message for the current user is received by the system.
Here we use ***WebSockets***, but the other available options could be

***WebSocket***: Websocket is a fully bi-directional connection, which means once a userA is connected to the server, both client and server can initiate a request. Websocket also has sticky session, which when used with load balancer helps the initial server only handle the response

***BOSH***: Bidirectional Streams over Synchronous HTTP, which means once a userA sends a request to the server, the server holds on the request till certain time has passed or it has some new data, at which point it will send a response back

***Long Poll HTTP***: Client sends a request to the server, the server can respond I don’t have the data, the client waits for some time and then initiates a new request

***MQTT***: MQTT is a lightweight publish/subscribe messaging protocol designed for M2M (machine to machine) telemetry in low bandwidth environments. The key component in MQTT is the MQTT broker. The main task of MQTT broker is dispatching messages to the MQTT clients (“subscribers”). In other words, the MQTT broker receives messages from publisher and dispatches these messages to the subscribers. While it dispatches messages, the MQTT broker uses the topic to filter the MQTT clients that will receive the message. The topic is a string, and it is possible to combine the topics creating topic levels.

Once a user opens our application, it will check with the backend, whether the current mobile number + device ID pair are previously registered or not. 
Else we prompt the user to authenticate with a SMS code, that will be generated by the server. Once the user authenticates with the provided SMS code, we register the device against the user (#reqt 7)

Now the application will connect to the **load balancer**, which will choose **a backend node**, say N2 for this session. 
Now the application will periodically heartbeat with Node N2 and this **heartbeat can be saved in a Redis** with the last heartbeat timestamp.
The idea being, **that when the backend needs to send a message to this user say U1, we can quickly find out which Node (N2 here) is connected to the U1 session.**
This way, the Node N2, doesn't need to periodically scan the database for fresh messages for U1

If the Node N2 dies, or application exits or the session is closed for any other reason, the heartbeat timestamp will tell us that the Node assignment is not valid.
Now if a new session is created and say Node N3 is connected to user U1, the cache will be updated with this information, and heartbeat timestamp.

Once Node N3 see that it is making a new entry in the Cache, it can scan the backend database for new messages and send them to the user.
This heartbeat mechanism is also used to find out when the user was last seen (# reqt 5)

Now suppose user U3 wants to send a message to user U1. The app will show U3 all the phone contacts available, and we can find out via a REST API whether the users are registered with our service or not. Once U3 selects U1 to chat with, and say U3 is connected to N4, the message M1, is sent to N4. N4 in turn saves the message to our database, and also looks up the cache to see if U1 is online, and which node it is connected to, N3 here.
N4 then sends the message, and the user info U1 to N3, which is turn sends the message to U1 over the websocket. N3 will also mark the message as received by U1. (#reqt 4)

Consider the case when U3 wants to send a message to U2 who is not online. In this case N3 sees that there is no current session/node for U2, and just stored the message in the database. When user U2 comes online, its connected server and scan the database for the available offline messages and send them to U2. (#reqt 2)

Similarly, the user can create groups, which can be modelled just like above, where instead of the user's U3 node connecting to a single node, sends the incoming message to multiple nodes for the currently active users.

### Security

We want the messages to be end-to-end encrypted, i.e. the messages are not sent as plain text, but encrypted on the device before being sent over the network. <br>
For this, for a conversation between U1 and U2, the first time a conversation is initiated, we generate an unique encryption key on the server, and provide this encryption key to our app. The application uses this key for encryption for sending messages between U1 and U2 ***only***.
The same encryption key is also provided to the application running with user U2, and only it can decrypt the message.
For each conversation, we use a different encryption key, for better security, and isolation guarantee.

### Database Design

Obviously, we need a NoSQL database to host the messages. I would use Apache Cassandra here, which is a free and open-source, distributed, wide column store, NoSQL database management system designed to handle large amounts of data across many commodity servers, providing high availability with no single point of failure.

Cassandra is wide column store, and, as such, essentially a hybrid between a key-value and a tabular database management system. Its data model is a partitioned row store with tunable consistency.Rows are organized into tables; the first component of a table's primary key is the partition key; within a partition, rows are clustered by the remaining columns of the key. Other columns may be indexed separately from the primary key.

Cassandra has the concept of Primary Keys, Composite Primary Keys, Partition Keys and Clustering Keys


***Primary key*** concept in Cassandra is different from Relational databases. When you lookup data in Cassandra, for best performance, you must provide the Primary Key.

***Partition key*** is responsible for distributing data among nodes. A partition key is the same as the primary key when the primary key consists of a single column.
Partition keys belong to a node. Cassandra is organized into a cluster of nodes, with each node having an equal part of the partition key hashes.

***Composite keys*** are partition keys that consist of multiple columns.

***Clustering keys*** are responsible for sorting data within a partition. Each primary key column after the partition key is considered a clustering key.

Take the following examples
1. K1: primary key has only one partition key and no cluster key.
2. (K1, K2): column K1 is a partition key and column K2 is a cluster key.
3. (K1,K2,K3,...): column K1 is a partition key and columns K2, K3 and so on make cluster key.
4. (K1, (K2, K3,...)): It is same as 3 i.e column K1 is a partition key and columns K2,K3,... make cluster key.
5. ((K1, K2,...), (K3,K4,...)): columns K1, K2 make partition key and columns K3,K4,... make cluster key.

Imagine we have a four node Cassandra cluster. In the example cluster below, Node 1 is responsible for partition key hash values 0-24; Node 2 is responsible for partition key hash values 25-49; and so on.

![img](imgs/cassandra-cluster.png)



For our messaging sytem, could have the following tables

| UserInfo       | Stores the user info        |
|:---------------|---|
| UserID         |   The primary key which uniquely identifies the user for our system |
| MobileNumber   |   The current mobile number of the user |
| DeviceID       |   The current device of the user |
| RegisteredOn   |   The date user is first registered on our system |


| UserConnection   | Stores the U1-U2 connection info, as well as U2-U1 connection info using 2 rows    |
|:-----------------|---|
| User1            |   User1 is the primary key |
| User2            |   User2 is the clustering key |
| ConversationID   |   A unique conversation ID |
| EncryptionKey    |   The encryption key which is used to encrypt the messages between U1-U2. This key is itself encrypted with a master key before being stored  |


| GroupConnection | Stores the group connection info, where we can find out which groups a user belongs to, conversely, which users are in the group |
|:-----------------|---|
| GroupID            |   GroupID is the primary key |
| GroupName          |   The name of the group |
| UserID             |   UserID, which is the clustering key |
| ConversationID     |   A unique conversation ID |
| IsAdmin            |   Is this user a group admin, who can add/remove users |
| EncryptionKey      |   The encryption key which is used to encrypt the messages in this group. This key is itself encrypted with a master key before being stored  |


| Conversations    | Stores all the conversations |
|:-----------------|---|
| ConversationID     |   ConversationID is now the primary key |
| Time               |   The timestamp of the message is now the **Clustering** key, and messages are retrieved in sorted order |
| FromUserID          |   The user who sent the message |
| EncryptedMessage   |   The encrypted Message |
| SentTimestamp      |   The message sent timestamp  |


![img](imgs/whatsapp.svg)

### Capacity Estimation and Constraints
We need to build a highly scalable platform which can support traffic at the scale of WhatsApp. Additionally, while doing capacity planning, we need to ensure that we think through the worst-case scenarios of peak traffic. Some of the numbers which we can use for capacity estimations are listed below.

Number of users on the application every month: 1 Billion<br>
Number of active users per second at peak traffic: 650, 000<br>
Number of messages per second at peak traffic: 40 Million<br>

The entire application will consist of several microservices, each performing a specific task. The number of servers required in the data plane  handling the traffic of chat messages can be estimated using the following equation.

```
num_servers_reqd = (num_chat_msgs_per_second * latency) / num_concurrent_connections_per_server
```

Let’s assume that the number of concurrent connections per server is 100K, and the latency of sending a message is 20 milliseconds. In such a scenario, the estimated number of servers required in the chat servers’ fleet (using the equation mentioned above) will be 8 (i.e., 40 Million*20 ms/100K). In standard practice, it’s recommended to add a few more servers to account for handling failures of these servers. 


***NOTE***: In this [talk](https://vimeo.com/44312354), Rick Reed(software engineer @ WhatsApp) talks about optimizing their Erlang-based server applications and tuning the FreeBSD kernel to support millions of concurrent connections per server. This helped them to a great extent in keeping their server footprint as small as possible.
